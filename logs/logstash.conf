input {
  http {
    port => "${PORT}"
    user => "${USER}"
    password => "${PASSWORD}"
  }
}

filter {

  ####################################################
  # 1. Parse message body: JSON logs vs key=value logs
  ####################################################

  if [message] =~ /^\s*{/ {
    # Case: full JSON line
    json {
      source => "message"
      target => "msg"
      remove_field => ["message"]
      tag_on_failure => ["_jsonparsefailure"]
    }

    # Some apps put another "message" string inside the JSON that is itself "k=v k=v ..."
    if [msg][message] {
      kv {
        source => "[msg][message]"
        field_split => ", "
      }
    }

  } else {
    # Case: classic "k=v k=v" log line
    kv {
      source => "message"
      field_split => " "
      value_split => "="
      trim_key => "\""
      trim_value => "\""
    }

    mutate {
      convert => {
        "status"   => "integer"
        "duration" => "float"
        "bytes"    => "integer"
      }
    }
  }

  ####################################################
  # 2. Extract URL / query params (if request info exists)
  ####################################################

  if [headers][request_path] {
    grok {
      match => { "[headers][request_path]" => "%{URIPARAM:url}" }
      tag_on_failure => ["_grokparsefailure_requestpath"]
    }

    kv {
      source => "url"
      field_split => "&"
      trim_key => "?"
    }
  }

  # Headers are noisy; drop them once we've mined them
  mutate {
    remove_field => ["headers"]
  }

  ####################################################
  # 3. ECS-style normalization + prevent mapping conflicts
  ####################################################

  #
  # Step 3.1: capture any pre-existing 'host' (string) so we can turn it
  # into host.name later WITHOUT breaking mapping
  #
  if [host] and [host] !~ "^\s*$" and [host] !~ "^\{.*\}$" {
    # only rename if host is not already an object
    mutate {
      rename => { "host" => "host_original" }
    }
  }

  #
  # Step 3.2: service name (logical app) from 'appname' or 'source'
  # - You had 'appname' => "pa-front-staging"
  # - Sometimes you had 'source' => "pa-back-staging"
  #
  mutate {
    # prefer appname, fallback source
    coalesce => { "[service][name]" => ["appname", "source"] }

    # request container/dyno name: we saw "container=web-1" or "hostname=router"
    coalesce => { "container_name_tmp" => ["container", "hostname"] }
  }

  #
  # Step 3.3: fill host.name from host_original if we had it
  #
  if [host_original] {
    mutate {
      add_field => {
        "[host][name]" => "%{host_original}"
      }
    }
  }

  #
  # Step 3.4: set top-level container field (string ONLY)
  # We do NOT create [container][name] object anymore because ES mapped
  # container as keyword already and rejected {name: ...}
  #
  if [container_name_tmp] {
    mutate {
      replace => { "container" => "%{container_name_tmp}" }
    }
  }

  #
  # Step 3.5: cleanup helper fields and noisy leftovers
  #
  mutate {
    remove_field => [
      "host_original",
      "container_name_tmp",
      "appname",
      "source",
      "hostname"
    ]
  }
}

output {
  elasticsearch {
    hosts    => "${ELASTICSEARCH_HOST}"
    user     => "${ELASTICSEARCH_USER}"
    password => "${ELASTICSEARCH_PASSWORD}"

    # OPTION 1: classic daily index (what you're doing now)
    index    => "logs-${ENVIRONMENT}-%{+YYYY.MM.dd}"

    action   => "create"
  }

  stdout {
    codec => rubydebug
  }
}
