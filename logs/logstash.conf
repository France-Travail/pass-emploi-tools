input {
  http {
    port => "${PORT}"
    user => "${USER}"
    password => "${PASSWORD}"
  }
}

filter {

  ####################################################
  # 1. Parse le message : JSON structuré vs log texte key=value
  ####################################################

  if [message] =~ /^\s*{/ {
    # Cas JSON
    json {
      source => "message"
      target => "msg"
      remove_field => ["message"]
      tag_on_failure => ["_jsonparsefailure"]
    }

    if [msg][message] {
      kv {
        source => "[msg][message]"
        field_split => ", "
      }
    }

  } else {
    # Cas log type "method=GET path=/... duration=0.01s ..."
    kv {
      source => "message"
      field_split => " "
      value_split => "="
      trim_key => "\""
      trim_value => "\""
    }

    mutate {
      convert => {
        "status"   => "integer"
        "duration" => "float"
        "bytes"    => "integer"
      }
    }
  }

  ####################################################
  # 2. Découper l'URL / query params si on a la route HTTP
  ####################################################

  if [headers][request_path] {
    grok {
      match => { "[headers][request_path]" => "%{URIPARAM:url}" }
      tag_on_failure => ["_grokparsefailure_requestpath"]
    }

    kv {
      source => "url"
      field_split => "&"
      trim_key => "?"
    }
  }

  # on n'a plus trop besoin des headers bruts en index (ça spamme)
  mutate {
    remove_field => ["headers"]
  }

  ####################################################
  # 3. Normalisation ECS (service.name, container.name, host.name)
  #    + résolution du conflit "host was string vs object"
  ####################################################

  # Sauvegarder l'ancien host brut si présent (string ou IP)
  if [host] and [host] !~ "^\s*$" {
    mutate {
      rename => { "host" => "host_original" }
    }
  }

  # Regrouper les renames et ajouts ECS dans UN SEUL mutate
  mutate {
    # service.name = ton app logique (ex: pa-front-staging)
    rename => { "source" => "[service][name]" }

    # container.name = dyno/pod (ex: web-1, router, etc.)
    rename => { "container" => "[container][name]" }
  }

  # Si on a host_original, alors on crée host.name à partir de ça
  if [host_original] {
    mutate {
      add_field => {
        "[host][name]" => "%{host_original}"
      }
    }
  }

  # Cleanup du champ temporaire
  mutate {
    remove_field => ["host_original"]
  }
}

output {
  elasticsearch {
    hosts    => "${ELASTICSEARCH_HOST}"
    user     => "${ELASTICSEARCH_USER}"
    password => "${ELASTICSEARCH_PASSWORD}"
    index    => "logs-${ENVIRONMENT}-%{+YYYY.MM.dd}"
    action   => "create"
  }

  stdout {
    codec => rubydebug
  }
}
